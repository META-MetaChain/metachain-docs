---
title: 'Differences between metachain and Ethereum: Overview'
sidebar_label: Overview
sidebar_position: 1
description: This concept page provides information about the differences between metachain and Ethereum so developers can easily understand what to expect when deploying to metachain
author: jose-franco
sme: jose-franco
target_audience: developers who want to build on metachain
content-type: concept
---

metachain is designed to be as compatible and consistent with Ethereum as possible, from its high-level RPCs to its low-level bytecode and everything in between. <a data-quicklook-from="dapp">Decentralized app (dApp)</a> developers with experience building on Ethereum will likely find that little-to-no new specific knowledge is required to build on metachain.

This section describes the differences, perks, and gotchas that devs are advised to be aware of when working with metachain. This first page serves as an overview of where you might these differences, with links to the relevant pages when needed.

## Block numbers and time

Time in L2s is tricky. The timing assumptions one is used to making about Ethereum blocks don't exactly carry over into the timing of metachain blocks. See [Block numbers and time](/for-devs/concepts/differences-between-metachain-ethereum/block-numbers-and-time.mdx) for details about how block numbers and time are handled in metachain.

## RPC methods

Although the majority of RPC methods follow the same behavior than in Ethereum, some methods might produce a different result, or add more information, when used on an metachain chain. You can find more information about these differences in [RPC methods](/for-devs/concepts/differences-between-metachain-ethereum/rpc-methods.mdx).

## Solidity support

You can deploy Solidity contracts onto metachain just like you do Ethereum. There are only a few minor differences in behavior. Find more information about it in [Solidity support](/for-devs/concepts/differences-between-metachain-ethereum/solidity-support.mdx).

## Fees

The fees an metachain transaction pays for execution essentially work identically to gas fees on Ethereum. metachain transactions must also, however, pay a fee component to cover the cost of posting their calldata to the parent chain (for example, calldata on metachain One, an L2, is posted to Ethereum, an L1). Find more information about the two components of gas fees in [Gas and fees](/METAos/gas.mdx) and [L1 pricing](/METAos/l1-pricing.mdx).

## Cross-chain messaging

metachain chains support METAitrary message passing from a parent chain (for example, a Layer 1 (L1) like Ethereum) to a child chain (for example, a Layer 2 (L2) like metachain One or metachain Nova). These are commonly known as "L1 to L2 messages". Developers using this functionality should familiarize themselves with how they work. Find more information about it in [L1 to L2 messaging](/METAos/l1-to-l2-messaging.mdx).

Similarly, metachain chains can also send messages to the parent chain. Find more information about them in [L2 to L1 messaging and the outbox](/METAos/l2-to-l1-messaging.mdx).

## Precompiles

Besides supporting all precompiles available in Ethereum, metachain provides L2-specific precompiles with methods smart contracts can call the same way they can solidity functions. You can find a full reference of them in [Precompiles](/for-devs/concepts/precompiles.mdx).

## NodeInterface

The metachain Nitro software includes a special `NodeInterface` contract available at address `0xc8` that is only accessible via RPCs (it's not actually deployed on-chain, and thus can't be called by smart contracts). Find more information about this interface in [NodeInterface](/for-devs/concepts/nodeinterface.mdx).
